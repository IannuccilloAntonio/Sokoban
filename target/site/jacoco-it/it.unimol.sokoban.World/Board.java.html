<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Sokoban</a> &gt; <a href="index.source.html" class="el_package">it.unimol.sokoban.World</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">package it.unimol.sokoban.World;

import it.unimol.sokoban.Player.Actor;
import it.unimol.sokoban.Player.Baggage;
import it.unimol.sokoban.Player.Player;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.*;


/** Classe per la creazione di tutta l'area di gioco
 * @author Iannuccillo Antonio
 * @version 1.0
 */
public class Board extends JPanel {


    //Distanza tra i bordi della finestra e bordi del gioco
<span class="fc" id="L23">    private final int OFFSET = 30;</span>

    // DIMENSIONE DELLE PARETI INTERNE 20X20
<span class="fc" id="L26">    private final int SPACE = 20;</span>

    /** 4 Tipi di collisioni identificate da costanti**/
<span class="fc" id="L29">    private final int LEFT_COLLISION = 1;</span>
<span class="fc" id="L30">    private final int RIGHT_COLLISION = 2;</span>
<span class="fc" id="L31">    private final int TOP_COLLISION = 3;</span>
<span class="fc" id="L32">    private final int BOTTOM_COLLISION = 4;</span>



    private ArrayList&lt;Wall&gt; walls;
    private ArrayList&lt;Baggage&gt; baggs;
    private ArrayList&lt;Area&gt; areas;

    private Player soko;

<span class="fc" id="L42">    private int widht = 0;</span>
<span class="fc" id="L43">    private int height = 0;</span>

<span class="fc" id="L45">    private boolean isCompleted = false;</span>

    /** Struttura del livello del gioco
     * # corrisponde al muro
     * $ corrisponde alle pedine da spostare
     * . rappresenta il posto dove dobbiamo spostare le pedine
     * @ è il sokoban ovvero il nostro personaggio
     * \n per andare accapo e creare un nuovo muro
     * **/
<span class="fc" id="L54">    private String level</span>
            = &quot;    ######\n&quot;
            + &quot;    ##   #\n&quot;
            + &quot;    ##$  #\n&quot;
            + &quot;  ####  $##\n&quot;
            + &quot;  ##  $ $ #\n&quot;
            + &quot;#### # ## #   ######\n&quot;
            + &quot;##   # ## #####  ..#\n&quot;
            + &quot;## $      $      ..#\n&quot;
            + &quot;###### ### #@##  ..#\n&quot;
            + &quot;    ##     #########\n&quot;
            + &quot;    ########\n&quot;;

    public String name;

    /** Metodo per la creazione della finestra
     * Chiama il meotodo {@link #initBoard()} per inizializzare la finestra di gioco
     */
<span class="fc" id="L72">    public Board() {</span>
        /*String response;
        response = JOptionPane.showInputDialog(&quot;Inserisci il tuo nome&quot;);
        this.name = response;*/
<span class="fc" id="L76">        initBoard();</span>

<span class="fc" id="L78">    }</span>

    /** Inizializza la finestra di gioco
     * Chiama il meotodo {@link #initWorld()} per inizializzare l'area di gioco
     * Chiama la classe {@link TAdapter} per gestire i movimenti dei giocatori
     */
    private void initBoard() {

<span class="fc" id="L86">        addKeyListener(new TAdapter());</span>
<span class="fc" id="L87">        setFocusable(true);</span>
<span class="fc" id="L88">        initWorld();</span>
<span class="fc" id="L89">    }</span>


    public int getBoardWidth() {
<span class="fc" id="L93">        return this.widht;</span>
    }


    public int getBoardHeight() {
<span class="fc" id="L98">        return this.height;</span>
    }

    /** Metodo che associa agli oggetti del livello la varie collection
     * @return void**/
    private void initWorld() {

<span class="fc" id="L105">        walls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L106">        baggs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L107">        areas = new ArrayList&lt;&gt;();</span>

        /** Inizializzazione della distanza delle finestra dal gioco **/
<span class="fc" id="L110">        int x = OFFSET;</span>
<span class="fc" id="L111">        int y = OFFSET;</span>


        Wall wall;
        Baggage baggage;
        Area area;

<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (int i = 0; i &lt; level.length(); i++) {</span>

<span class="fc" id="L120">            char item = level.charAt(i);</span>

<span class="pc bpc" id="L122" title="1 of 7 branches missed.">            switch (item) {</span>


                case '\n':

<span class="fc" id="L127">                    y += SPACE;</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">                    if (this.widht &lt; x) {</span>
<span class="fc" id="L130">                        this.widht = x;</span>
                    }

<span class="fc" id="L133">                    x = OFFSET;</span>
<span class="fc" id="L134">                    break;</span>

                    /*Creazione di un muro e aggiunto alla collection dei muri
                     Ogni volta che si incrementa un muro aumenta la grandezza della x */
                case '#':
<span class="fc" id="L139">                    wall = new Wall(x, y);</span>
<span class="fc" id="L140">                    walls.add(wall);</span>
<span class="fc" id="L141">                    x += SPACE;</span>
<span class="fc" id="L142">                    break;</span>

                case '$':
<span class="fc" id="L145">                    baggage = new Baggage(x, y);</span>
<span class="fc" id="L146">                    baggs.add(baggage);</span>
<span class="fc" id="L147">                    x += SPACE;</span>
<span class="fc" id="L148">                    break;</span>

                case '.':
<span class="fc" id="L151">                    area = new Area(x, y);</span>
<span class="fc" id="L152">                    areas.add(area);</span>
<span class="fc" id="L153">                    x += SPACE;</span>
<span class="fc" id="L154">                    break;</span>

                case '@':
<span class="fc" id="L157">                    soko = new Player(x, y);</span>
<span class="fc" id="L158">                    x += SPACE;</span>
<span class="fc" id="L159">                    break;</span>

                case ' ':
<span class="fc" id="L162">                    x += SPACE;</span>
<span class="fc" id="L163">                    break;</span>

                default:
                    break;
            }

<span class="fc" id="L169">            height = y;</span>
        }

<span class="fc" id="L172">    }</span>

    /** Metodo per disegnare i vari oggetti, creando il nuovo mondo selezionando gli oggetti
     * dalle collection
     * @param g Metodo per disegnare il mondo
     * **/
    private void buildWorld(Graphics g) {

<span class="nc" id="L180">        g.setColor(new Color(250, 240, 170));</span>
<span class="nc" id="L181">        g.fillRect(0, 0, this.getWidth(), this.getHeight());</span>
<span class="nc" id="L182">        g.setColor(new Color(0, 0, 0));</span>

<span class="nc" id="L184">        g.drawString(&quot;Press R to restart&quot;, 15, 20);</span>
<span class="nc" id="L185">        g.drawString(&quot;Player: &quot; + this.name, 15, 50);</span>

<span class="nc" id="L187">        ArrayList&lt;Actor&gt; world = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L189">        world.addAll(walls);</span>
<span class="nc" id="L190">        world.addAll(areas);</span>
<span class="nc" id="L191">        world.addAll(baggs);</span>
<span class="nc" id="L192">        world.add(soko);</span>


        /** Disegno ogni oggetto **/
<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (int i = 0; i &lt; world.size(); i++) {</span>

<span class="nc" id="L198">            Actor item = world.get(i);</span>

            //Posizionamento del Sokoban pirncipale nello spazio vuoto
<span class="nc bnc" id="L201" title="All 4 branches missed.">            if (item instanceof Player || item instanceof Baggage) {</span>
<span class="nc" id="L202">                g.drawImage(item.getImage(), item.getX() + 2, item.getY() + 2, this);</span>
            } else {
                //Posizionamento delle pedine negli spazii
<span class="nc" id="L205">                g.drawImage(item.getImage(), item.getX(), item.getY(), this);</span>
            }

<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (isCompleted) {</span>

<span class="nc" id="L210">                g.setColor(new Color(0, 0, 0));</span>
<span class="nc" id="L211">                g.drawString(&quot;Completed&quot;, 305, 20);</span>

            }

        }
<span class="nc" id="L216">    }</span>

    /** Metodo per disegnare tutti le componenti create sull'area di gioco
     * Chiama il meotodo {@link #buildWorld(Graphics)} per prendere gli oggetti creati
     * e metterli sull'area di gioco**/
    @Override
    public void paintComponent(Graphics g) {
<span class="nc" id="L223">        super.paintComponent(g);</span>

<span class="nc" id="L225">        buildWorld(g);</span>
<span class="nc" id="L226">    }</span>
    /** Classe per gestire i movimenti del sokobane.
     * @author Iannuccillo Antonio
     * @version 1.0**/
<span class="fc" id="L230">    private class TAdapter extends KeyAdapter {</span>


        @Override
        public void keyPressed(KeyEvent e) {

            //Se il gioco è completato allora non si possono muovere più gli oggetti
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (isCompleted) {</span>
<span class="nc" id="L238">                return;</span>
            }

<span class="nc" id="L241">            int key = e.getKeyCode();</span>

<span class="nc bnc" id="L243" title="All 6 branches missed.">            switch (key) {</span>

                case KeyEvent.VK_LEFT:


<span class="nc bnc" id="L248" title="All 2 branches missed.">                    if (checkWallCollision(soko,</span>
                            LEFT_COLLISION)) {
<span class="nc" id="L250">                        return;</span>
                    }

<span class="nc bnc" id="L253" title="All 2 branches missed.">                    if (checkBagCollision(LEFT_COLLISION)) {</span>
<span class="nc" id="L254">                        return;</span>
                    }

<span class="nc" id="L257">                    soko.move(-SPACE, 0);</span>

<span class="nc" id="L259">                    break;</span>

                case KeyEvent.VK_RIGHT:

<span class="nc bnc" id="L263" title="All 2 branches missed.">                    if (checkWallCollision(soko, RIGHT_COLLISION)) {</span>
<span class="nc" id="L264">                        return;</span>
                    }

<span class="nc bnc" id="L267" title="All 2 branches missed.">                    if (checkBagCollision(RIGHT_COLLISION)) {</span>
<span class="nc" id="L268">                        return;</span>
                    }

<span class="nc" id="L271">                    soko.move(SPACE, 0);</span>

<span class="nc" id="L273">                    break;</span>

                case KeyEvent.VK_UP:

<span class="nc bnc" id="L277" title="All 2 branches missed.">                    if (checkWallCollision(soko, TOP_COLLISION)) {</span>
<span class="nc" id="L278">                        return;</span>
                    }

<span class="nc bnc" id="L281" title="All 2 branches missed.">                    if (checkBagCollision(TOP_COLLISION)) {</span>
<span class="nc" id="L282">                        return;</span>
                    }

<span class="nc" id="L285">                    soko.move(0, -SPACE);</span>

<span class="nc" id="L287">                    break;</span>

                case KeyEvent.VK_DOWN:

<span class="nc bnc" id="L291" title="All 2 branches missed.">                    if (checkWallCollision(soko, BOTTOM_COLLISION)) {</span>
<span class="nc" id="L292">                        return;</span>
                    }

<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if (checkBagCollision(BOTTOM_COLLISION)) {</span>
<span class="nc" id="L296">                        return;</span>
                    }

<span class="nc" id="L299">                    soko.move(0, SPACE);</span>

<span class="nc" id="L301">                    break;</span>

                case KeyEvent.VK_R:

<span class="nc" id="L305">                    restartLevel();</span>

<span class="nc" id="L307">                    break;</span>

                default:
                    break;
            }
<span class="nc" id="L312">            repaint();</span>
<span class="nc" id="L313">        }</span>
    }
    /** Metodo per garantire che un sokoban o una pedina non superino il muro
     * @param actor oggetto che sia sokoban o pedina
     * @param type tipo di collisione
     * @see Actor per vedere i metodi per il controllo delle collisioni**/
    private boolean checkWallCollision(Actor actor, int type) {

<span class="nc bnc" id="L321" title="All 5 branches missed.">        switch (type) {</span>

            case LEFT_COLLISION:

<span class="nc bnc" id="L325" title="All 2 branches missed.">                for (int i = 0; i &lt; walls.size(); i++) {</span>

<span class="nc" id="L327">                    Wall wall = walls.get(i);</span>


<span class="nc bnc" id="L330" title="All 2 branches missed.">                    if (actor.isLeftCollision(wall)) {</span>

<span class="nc" id="L332">                        return true;</span>
                    }
                }

<span class="nc" id="L336">                return false;</span>

            case RIGHT_COLLISION:

<span class="nc bnc" id="L340" title="All 2 branches missed.">                for (int i = 0; i &lt; walls.size(); i++) {</span>

<span class="nc" id="L342">                    Wall wall = walls.get(i);</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">                    if (actor.isRightCollision(wall)) {</span>
<span class="nc" id="L345">                        return true;</span>
                    }
                }

<span class="nc" id="L349">                return false;</span>

            case TOP_COLLISION:

<span class="nc bnc" id="L353" title="All 2 branches missed.">                for (int i = 0; i &lt; walls.size(); i++) {</span>

<span class="nc" id="L355">                    Wall wall = walls.get(i);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">                    if (actor.isTopCollision(wall)) {</span>

<span class="nc" id="L359">                        return true;</span>
                    }
                }

<span class="nc" id="L363">                return false;</span>

            case BOTTOM_COLLISION:

<span class="nc bnc" id="L367" title="All 2 branches missed.">                for (int i = 0; i &lt; walls.size(); i++) {</span>

<span class="nc" id="L369">                    Wall wall = walls.get(i);</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">                    if (actor.isBottomCollision(wall)) {</span>

<span class="nc" id="L373">                        return true;</span>
                    }
                }

<span class="nc" id="L377">                return false;</span>

            default:
                break;
        }

<span class="nc" id="L383">        return false;</span>
    }

    /** Una pedina può scontrarsi con un muro, con un oggetto sokoban o con un altra pedina.
    * La pedina può essere spostato solo se si scontra con un sokoban e non si scontra con un altra pedina o un muro.
    * Quando la pedina viene spostata bisogna sempre controllare se il gioco è finito**/
    private boolean checkBagCollision(int type) {

<span class="nc bnc" id="L391" title="All 5 branches missed.">        switch (type) {</span>

            case LEFT_COLLISION:

<span class="nc bnc" id="L395" title="All 2 branches missed.">                for (int i = 0; i &lt; baggs.size(); i++) {</span>

<span class="nc" id="L397">                    Baggage bag = baggs.get(i);</span>

                    /** Se il sokoban si incontra con una pedina bisogna controllare se c'è un altra pedina avanti
                     * e controllare se c'è un muro**/
<span class="nc bnc" id="L401" title="All 2 branches missed.">                    if (soko.isLeftCollision(bag)) {</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">                        for (int j = 0; j &lt; baggs.size(); j++) {</span>

<span class="nc" id="L405">                            Baggage item = baggs.get(j);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">                            if (!bag.equals(item)) {</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">                                if (bag.isLeftCollision(item)) {</span>
<span class="nc" id="L410">                                    return true;</span>
                                }
                            }

<span class="nc bnc" id="L414" title="All 2 branches missed.">                            if (checkWallCollision(bag, LEFT_COLLISION)) {</span>
<span class="nc" id="L415">                                return true;</span>
                            }
                        }
                        /** Pedina si trova nel blocco finale con le altre pedine**/
<span class="nc" id="L419">                        bag.move(-SPACE, 0);</span>
<span class="nc" id="L420">                        isCompleted();</span>
                    }
                }

<span class="nc" id="L424">                return false;</span>

            case RIGHT_COLLISION:

<span class="nc bnc" id="L428" title="All 2 branches missed.">                for (int i = 0; i &lt; baggs.size(); i++) {</span>

<span class="nc" id="L430">                    Baggage bag = baggs.get(i);</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (soko.isRightCollision(bag)) {</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">                        for (int j = 0; j &lt; baggs.size(); j++) {</span>

<span class="nc" id="L436">                            Baggage item = baggs.get(j);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">                            if (!bag.equals(item)) {</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">                                if (bag.isRightCollision(item)) {</span>
<span class="nc" id="L441">                                    return true;</span>
                                }
                            }

<span class="nc bnc" id="L445" title="All 2 branches missed.">                            if (checkWallCollision(bag, RIGHT_COLLISION)) {</span>
<span class="nc" id="L446">                                return true;</span>
                            }
                        }

                        /** Pedina si trova nel blocco finale con le altre pedine**/
<span class="nc" id="L451">                        bag.move(SPACE, 0);</span>
<span class="nc" id="L452">                        isCompleted();</span>
                    }
                }
<span class="nc" id="L455">                return false;</span>

            case TOP_COLLISION:

<span class="nc bnc" id="L459" title="All 2 branches missed.">                for (int i = 0; i &lt; baggs.size(); i++) {</span>

<span class="nc" id="L461">                    Baggage bag = baggs.get(i);</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">                    if (soko.isTopCollision(bag)) {</span>

<span class="nc bnc" id="L465" title="All 2 branches missed.">                        for (int j = 0; j &lt; baggs.size(); j++) {</span>

<span class="nc" id="L467">                            Baggage item = baggs.get(j);</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">                            if (!bag.equals(item)) {</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">                                if (bag.isTopCollision(item)) {</span>
<span class="nc" id="L472">                                    return true;</span>
                                }
                            }

<span class="nc bnc" id="L476" title="All 2 branches missed.">                            if (checkWallCollision(bag, TOP_COLLISION)) {</span>
<span class="nc" id="L477">                                return true;</span>
                            }
                        }

<span class="nc" id="L481">                        bag.move(0, -SPACE);</span>
<span class="nc" id="L482">                        isCompleted();</span>
                    }
                }

<span class="nc" id="L486">                return false;</span>

            case BOTTOM_COLLISION:

<span class="nc bnc" id="L490" title="All 2 branches missed.">                for (int i = 0; i &lt; baggs.size(); i++) {</span>

<span class="nc" id="L492">                    Baggage bag = baggs.get(i);</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">                    if (soko.isBottomCollision(bag)) {</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">                        for (int j = 0; j &lt; baggs.size(); j++) {</span>

<span class="nc" id="L498">                            Baggage item = baggs.get(j);</span>

<span class="nc bnc" id="L500" title="All 2 branches missed.">                            if (!bag.equals(item)) {</span>

<span class="nc bnc" id="L502" title="All 2 branches missed.">                                if (bag.isBottomCollision(item)) {</span>
<span class="nc" id="L503">                                    return true;</span>
                                }
                            }

<span class="nc bnc" id="L507" title="All 2 branches missed.">                            if (checkWallCollision(bag,BOTTOM_COLLISION)) {</span>

<span class="nc" id="L509">                                return true;</span>
                            }
                        }

<span class="nc" id="L513">                        bag.move(0, SPACE);</span>
<span class="nc" id="L514">                        isCompleted();</span>
                    }
                }

<span class="nc" id="L518">                break;</span>

            default:
                break;
        }

<span class="nc" id="L524">        return false;</span>
    }

    /** Metodo che controlla se tutte le pedine sono nell'area finale
     * **/
    public void isCompleted() {

<span class="nc" id="L531">        int numberOfBags = baggs.size();</span>
<span class="nc" id="L532">        int finishedBags = 0;</span>

        /** Controllo che tutte le pedine siano nell'area finale **/
<span class="nc bnc" id="L535" title="All 2 branches missed.">        for (int i = 0; i &lt; numberOfBags; i++) {</span>

<span class="nc" id="L537">            Baggage bag = baggs.get(i);</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">            for (int j = 0; j &lt; numberOfBags; j++) {</span>

<span class="nc" id="L541">                Area area =  areas.get(j);</span>

<span class="nc bnc" id="L543" title="All 4 branches missed.">                if (bag.getX() == area.getX() &amp;&amp; bag.getY() == area.getY()) {</span>

                    /** Contatore che somma le pedine presenti nell'area finale **/
<span class="nc" id="L546">                    finishedBags += 1;</span>
                }
            }
        }

        /** Se il numero di pedine nell'area finale corrisponde al numero di pedine
         * create allora il gioco è concluso **/
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (finishedBags == numberOfBags) {</span>

<span class="nc" id="L555">            isCompleted = true;</span>
<span class="nc" id="L556">            repaint();</span>
        }
<span class="nc" id="L558">    }</span>

    /** Metodo che ritorna allo stato iniziale il gioco **/
    public void restartLevel() {

<span class="nc" id="L563">        areas.clear();</span>
<span class="nc" id="L564">        baggs.clear();</span>
<span class="nc" id="L565">        walls.clear();</span>

<span class="nc" id="L567">        initWorld();</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (isCompleted) {</span>
<span class="nc" id="L570">            isCompleted = false;</span>
        }
<span class="nc" id="L572">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>